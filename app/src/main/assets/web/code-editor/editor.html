<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Legado Editor Pro</title>
  <style>
    :root {
      --bg: #ffffff;
      --gutter-bg: #f5f5f5;
      --gutter-text: #b0b0b0;
      --text: #24292e;
      --border: #e1e4e8;
      --active-line: #f6f8fa;
      --accent: #0366d6;
      --toolbar-bg: #f8f9fa;
      --selection: #b3d7ff;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1e1e1e;
        --gutter-bg: #252526;
        --gutter-text: #858585;
        --text: #d4d4d4;
        --border: #3e3e42;
        --active-line: #2d2d30;
        --accent: #40a9ff;
        --toolbar-bg: #252526;
        --selection: #264f78;
      }
    }

    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    body {
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px;
      background: var(--toolbar-bg);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
      flex-shrink: 0;
    }
    #toolbar::-webkit-scrollbar { display: none; }

    .btn {
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
    }
    .btn:active { opacity: 0.7; }
    .btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--active-line);
    }

    #editor-container {
      position: relative;
      flex: 1;
      display: flex;
      min-height: 0;
    }

    #lines {
      width: 45px;
      padding: 10px 5px 10px 0;
      background: var(--gutter-bg);
      color: var(--gutter-text);
      text-align: right;
      font-size: 13px;
      line-height: 1.5;
      border-right: 1px solid var(--border);
      overflow: hidden;
      user-select: none;
      white-space: pre;
    }

    #code {
      flex: 1;
      border: 0;
      padding: 10px;
      margin: 0;
      font-size: 13px;
      line-height: 1.5;
      outline: none;
      resize: none;
      background: transparent;
      color: var(--text);
      overflow: auto;
      white-space: pre;
      tab-size: 2;
    }
    #code::selection { background: var(--selection); }

    /* ÊêúÁ¥¢Ê°Ü */
    #search-box {
      position: absolute;
      top: 0; right: 0;
      background: var(--toolbar-bg);
      padding: 8px;
      border-bottom: 1px solid var(--border);
      border-left: 1px solid var(--border);
      display: none;
      align-items: center;
      gap: 5px;
      z-index: 10;
    }
    #search-box.visible { display: flex; }
    #search-input {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 4px 8px;
      width: 120px;
    }

    #toast {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 20;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>

  <div id="toolbar">
    <button id="undoBtn" class="btn">Êí§ÈîÄ</button>
    <button id="redoBtn" class="btn">ÈáçÂÅö</button>
    <button id="wrapBtn" class="btn">Êç¢Ë°å</button>
    <button id="formatBtn" class="btn">Ê†ºÂºèÂåñ</button>
    <button id="searchToggleBtn" class="btn">üîç</button>
  </div>

  <div id="search-box">
    <input id="search-input" type="text" placeholder="Êü•Êâæ..." />
    <button id="findNextBtn" class="btn">‚Üì</button>
    <button id="replaceBtn" class="btn">ÊõøÊç¢</button>
    <button id="closeSearchBtn" class="btn" style="border:none;">√ó</button>
  </div>

  <div id="editor-container">
    <div id="lines">1</div>
    <textarea id="code" spellcheck="false" autocapitalize="off" autocomplete="off"></textarea>
  </div>

  <div id="toast"></div>

  <script>
    (function () {
      const code = document.getElementById("code");
      const lines = document.getElementById("lines");
      const toast = document.getElementById("toast");
      
      let isWrap = false;
      let historyStack = [];
      let historyIndex = -1;
      let lastValue = "";
      
      const TAB = "  "; // 2Á©∫Ê†ºÁº©Ëøõ

      // --- Ê†∏ÂøÉÔºöË°åÂè∑ÈÄªËæë (ÊÄßËÉΩ‰ºòÂåñÁâà) ---
      const updateLines = () => {
        const val = code.value;
        const lineCount = (val.match(/\n/g) || []).length + 1;
        if (lines.getAttribute('data-lines') != lineCount) {
           lines.textContent = Array.from({length: lineCount}, (_, i) => i + 1).join('\n');
           lines.setAttribute('data-lines', lineCount);
           lines.style.width = Math.max(3, String(lineCount).length + 1) + "ch";
        }
      };

      // ÊªöÂä®ÂêåÊ≠•
      let ticking = false;
      code.addEventListener("scroll", () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            lines.scrollTop = code.scrollTop;
            ticking = false;
          });
          ticking = true;
        }
      });

      code.addEventListener("input", () => {
        updateLines();
        saveHistory();
      });

      // --- ÂéÜÂè≤ËÆ∞ÂΩï ---
      function saveHistory() {
        const val = code.value;
        if (val === lastValue) return;
        if (historyIndex < historyStack.length - 1) {
          historyStack = historyStack.slice(0, historyIndex + 1);
        }
        historyStack.push(val);
        historyIndex++;
        if (historyStack.length > 50) {
          historyStack.shift();
          historyIndex--;
        }
        lastValue = val;
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          code.value = historyStack[historyIndex];
          lastValue = code.value;
          updateLines();
          showToast("Êí§ÈîÄ");
        }
      }

      function redo() {
        if (historyIndex < historyStack.length - 1) {
          historyIndex++;
          code.value = historyStack[historyIndex];
          lastValue = code.value;
          updateLines();
          showToast("ÈáçÂÅö");
        }
      }

      saveHistory(); // ÂàùÂßãÂåñ

      // --- Ê†ºÂºèÂåñÊ†∏ÂøÉÁÆóÊ≥ï (‰øÆÂ§çÁâà) ---
      
      // 1. ‰∏•Ê†º JSON Ê†ºÂºèÂåñ (ÊúÄ‰ºòÂÖà)
      function tryFormatJSON(text) {
        try {
          return JSON.stringify(JSON.parse(text), null, TAB);
        } catch (e) {
          return null;
        }
      }

      // 2. ÂÆΩÊùæ JS/JSON Ê†ºÂºèÂåñÔºà‰∏§Èò∂ÊÆµÔºöËßÑËåÉÊç¢Ë°å + Áº©ËøõÔºâ
      function normalizeJs(text) {
        let out = "";
        let inString = false;
        let stringChar = "";
        let escape = false;
        let inLineComment = false;
        let inBlockComment = false;
        let parenDepth = 0;

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          const next = text[i + 1];

          if (inLineComment) {
            out += ch;
            if (ch === "\n") inLineComment = false;
            continue;
          }
          if (inBlockComment) {
            out += ch;
            if (ch === "*" && next === "/") {
              out += next;
              i++;
              inBlockComment = false;
            }
            continue;
          }

          if (inString) {
            out += ch;
            if (escape) {
              escape = false;
            } else if (ch === "\\") {
              escape = true;
            } else if (ch === stringChar) {
              inString = false;
              stringChar = "";
            }
            continue;
          }

          if (ch === "/" && next === "/") {
            out += ch + next;
            i++;
            inLineComment = true;
            continue;
          }
          if (ch === "/" && next === "*") {
            out += ch + next;
            i++;
            inBlockComment = true;
            continue;
          }

          if (ch === '"' || ch === "'" || ch === "`") {
            inString = true;
            stringChar = ch;
            out += ch;
            continue;
          }

          if (ch === "(") {
            parenDepth++;
            out += ch;
            continue;
          }
          if (ch === ")") {
            parenDepth = Math.max(parenDepth - 1, 0);
            out += ch;
            continue;
          }

          if (ch === "{") {
            out += "{\n";
            continue;
          }
          if (ch === "}") {
            out += "\n}\n";
            continue;
          }
          if (ch === ";" && parenDepth === 0) {
            out += ";\n";
            continue;
          }
          if (ch === "," && parenDepth === 0) {
            out += ",\n";
            continue;
          }
          if (ch === "\r") continue;

          out += ch;
        }
        return out.replace(/\n{2,}/g, "\n");
      }

      function countBraceDelta(line) {
        let open = 0;
        let close = 0;
        let inString = false;
        let stringChar = "";
        let escape = false;

        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          const next = line[i + 1];

          if (!inString && ch === "/" && next === "/") {
            break;
          }
          if (!inString && ch === "/" && next === "*") {
            const end = line.indexOf("*/", i + 2);
            if (end === -1) break;
            i = end + 1;
            continue;
          }

          if (inString) {
            if (escape) {
              escape = false;
            } else if (ch === "\\") {
              escape = true;
            } else if (ch === stringChar) {
              inString = false;
              stringChar = "";
            }
            continue;
          }

          if (ch === '"' || ch === "'" || ch === "`") {
            inString = true;
            stringChar = ch;
            continue;
          }

          if (ch === "{" || ch === "[") open++;
          if (ch === "}" || ch === "]") close++;
        }
        return open - close;
      }

      function indentJsLines(text) {
        const lines = text.split("\n");
        const out = [];
        let indent = 0;

        lines.forEach(function (line) {
          let trimmed = line.trim();
          if (!trimmed) return;

          trimmed = normalizeKeywordLine(trimmed);
          const startsWithClose = /^[}\]]/.test(trimmed);
          if (startsWithClose) indent = Math.max(indent - 1, 0);

          let lineIndent = indent;
          if (/^(case\b|default\b)/.test(trimmed)) {
            lineIndent = Math.max(indent - 1, 0);
          }
          const canMerge =
            /^(else\b|catch\b|finally\b)/.test(trimmed) &&
            out.length > 0 &&
            out[out.length - 1].trim().endsWith("}");
          if (canMerge) {
            out[out.length - 1] = out[out.length - 1] + " " + trimmed;
          } else {
            out.push(TAB.repeat(lineIndent) + trimmed);
          }

          let delta = countBraceDelta(trimmed);
          if (startsWithClose) delta += 1;
          indent += delta;
          if (indent < 0) indent = 0;

          if (/^(case\b|default\b)/.test(trimmed) && /:\s*$/.test(trimmed)) {
            indent += 1;
          }
        });

        return out.join("\n");
      }

      function formatLooseJS(text) {
        const normalized = normalizeJs(text);
        return indentJsLines(normalized);
      }

      function formatCode() {
        const raw = code.value || "";
        const text = raw.trim();
        if (!text) return;

        const wrapper = detectWrapper(raw);
        if (wrapper) {
          const bodyText = (wrapper.body || "").trim();
          const formattedBody = bodyText ? formatLooseJS(bodyText) : "";
          let wrapped = "";
          if (wrapper.type === "prefix") {
            wrapped = wrapper.prefix + (formattedBody ? "\n" + formattedBody : "");
          } else if (wrapper.type === "tag") {
            wrapped = wrapper.open + (formattedBody ? "\n" + formattedBody + "\n" : "") + wrapper.close;
          } else if (wrapper.type === "moustache") {
            wrapped = "{{" + (formattedBody ? "\n" + formattedBody + "\n" : "") + "}}";
          } else {
            wrapped = formattedBody;
          }
          code.value = wrapped;
          updateLines();
          saveHistory();
          showToast("Ê†ºÂºèÂåñÂÆåÊàê");
          return;
        }
        
        // 1. Â∞ùËØïÊ†áÂáÜ JSON
        let formatted = tryFormatJSON(text);
        
        if (!formatted) {
            // 2. Â∞ùËØïÂÆΩÊùæ JS/JSON
            if (text.startsWith("{") || text.startsWith("[") || text.includes("function") || text.includes("var ")) {
                try {
                    formatted = formatLooseJS(text);
                } catch (e) {
                    console.error(e);
                }
            } else if (text.includes("<") && text.includes(">")) {
                // 3. ÁÆÄÂçïÁöÑ HTML Áº©Ëøõ
                formatted = formatHtml(text);
            } else {
                // 4. ÈÄöÁî®‰øùÂ∫ï
                formatted = formatLooseJS(text);
            }
        }

        if (formatted) {
            code.value = formatted;
            updateLines();
            saveHistory();
            showToast("Ê†ºÂºèÂåñÂÆåÊàê");
        } else {
            showToast("Ê†ºÂºèÂåñÂ§±Ë¥•");
        }
      }

      function formatHtml(html) {
        let tab = TAB;
        let result = '';
        let indent= '';
        html.split(/>\s*</).forEach(function(element) {
          if (element.match( /^\/\w/ )) {
            indent = indent.substring(tab.length);
          }
          result += indent + '<' + element + '>\r\n';
          // ÊéíÈô§ void tags (‰∏çÈúÄË¶ÅÈó≠ÂêàÁöÑÊ†áÁ≠æ)
          if (element.match( /^<?\w[^>]*[^\/]$/ ) && !/^br|^img|^hr|^input|^meta|^link/i.test(element) ) { 
            indent += tab;              
          }
        });
        return result.substring(1, result.length-3);
      }

      function normalizeKeywordLine(line) {
        return line
          .replace(/^else\s*if\s*\(/, "else if (")
          .replace(/^else\s*\{/, "else {")
          .replace(/^catch\s*\(/, "catch (")
          .replace(/^finally\s*\{/, "finally {");
      }

      function detectWrapper(rawText) {
        const raw = rawText || "";
        const trimmed = raw.trim();
        const jsPrefixMatch = raw.match(/^\s*@js:\s*[\r\n]?([\s\S]*)$/);
        if (jsPrefixMatch) {
          return { type: "prefix", prefix: "@js:", body: jsPrefixMatch[1] || "" };
        }
        const tagMatch = trimmed.match(/^<js>\s*([\s\S]*?)\s*<\/js>$/i);
        if (tagMatch) {
          return { type: "tag", open: "<js>", close: "</js>", body: tagMatch[1] };
        }
        const braceMatch = trimmed.match(/^\{\{\s*([\s\S]*?)\s*\}\}$/);
        if (braceMatch) {
          return { type: "moustache", body: braceMatch[1] };
        }
        return null;
      }

      // --- ‰∫ã‰ª∂ÁªëÂÆö ---
      document.getElementById("undoBtn").onclick = undo;
      document.getElementById("redoBtn").onclick = redo;
      document.getElementById("formatBtn").onclick = formatCode;
      
      const wrapBtn = document.getElementById("wrapBtn");
      wrapBtn.onclick = () => {
        isWrap = !isWrap;
        code.style.whiteSpace = isWrap ? "pre-wrap" : "pre";
        wrapBtn.classList.toggle("active", isWrap);
        updateLines();
        showToast("Ëá™Âä®Êç¢Ë°å: " + (isWrap ? "ÂºÄ" : "ÂÖ≥"));
      };

      // ÊêúÁ¥¢ÂäüËÉΩ
      const searchBox = document.getElementById("search-box");
      const searchInput = document.getElementById("search-input");
      document.getElementById("searchToggleBtn").onclick = () => {
        searchBox.classList.toggle("visible");
        if (searchBox.classList.contains("visible")) searchInput.focus();
      };
      document.getElementById("closeSearchBtn").onclick = () => searchBox.classList.remove("visible");

      document.getElementById("findNextBtn").onclick = () => {
        const query = searchInput.value;
        if (!query) return;
        const text = code.value;
        const startPos = code.selectionEnd;
        let index = text.indexOf(query, startPos);
        if (index === -1) { index = text.indexOf(query, 0); showToast("Â∑≤ÂõûÂà∞È°∂ÈÉ®"); }
        if (index !== -1) {
            code.setSelectionRange(index, index + query.length);
            code.focus();
            const lineHeight = 20; 
            const linesBefore = text.substring(0, index).split('\n').length;
            code.scrollTop = (linesBefore * lineHeight) - (code.clientHeight / 2);
        } else { showToast("Êú™ÊâæÂà∞ÂÜÖÂÆπ"); }
      };

      document.getElementById("replaceBtn").onclick = () => {
          const query = searchInput.value;
          const replacement = prompt("ÊõøÊç¢‰∏∫:");
          if (query && replacement !== null) {
              code.value = code.value.split(query).join(replacement);
              updateLines(); saveHistory(); showToast("ÂÖ®ÈÉ®ÊõøÊç¢ÂÆåÊàê");
          }
      };

      function insertText(text) {
        const start = code.selectionStart;
        const end = code.selectionEnd;
        code.setRangeText(text, start, end, "end");
        code.dispatchEvent(new Event('input'));
      }

      // Âø´Êç∑ÈîÆÂ¢ûÂº∫
      code.addEventListener("keydown", function (e) {
        if (e.key === "Tab") {
          e.preventDefault();
          insertText(TAB);
        }
        if (e.key === "Enter") {
          e.preventDefault();
          const cursor = code.selectionStart;
          const currentLineStart = code.value.lastIndexOf("\n", cursor - 1) + 1;
          const currentLine = code.value.substring(currentLineStart, cursor);
          const indent = (currentLine.match(/^\s*/) || [""])[0];
          const extraIndent = /[{[:]\s*$/.test(currentLine) ? TAB : "";
          insertText("\n" + indent + extraIndent);
        }
      });

      function showToast(msg) {
        toast.textContent = msg;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 1500);
      }

      // --- Android Interface ---
      function b64ToUtf8(b64) {
        try { return decodeURIComponent(escape(window.atob(b64))); } catch (e) { return ""; }
      }

      window.setCodeFromAndroid = function (b64) {
        code.value = b64ToUtf8(b64);
        updateLines();
        saveHistory();
        code.scrollTop = 0;
        lines.scrollTop = 0;
      };

      window.__save = function () {
        const val = code.value || "";
        if (window.Android && window.Android.save) window.Android.save(val);
        else console.log("Mock Save:", val);
      };

      window.__getCode = function () {
        return code.value || "";
      };
      
      updateLines();
    })();
  </script>
</body>
</html>
