<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Legado Editor Pro</title>
  <style>
    :root {
      --bg: #ffffff;
      --gutter-bg: #f5f5f5;
      --gutter-text: #b0b0b0;
      --text: #24292e;
      --border: #e1e4e8;
      --active-line: #f6f8fa;
      --accent: #0366d6;
      --toolbar-bg: #f8f9fa;
      --selection: #b3d7ff;
      color-scheme: light;
    }

    @media (prefers-color-scheme: dark) {
      body:not([data-theme]) {
        --bg: #1e1e1e;
        --gutter-bg: #252526;
        --gutter-text: #858585;
        --text: #d4d4d4;
        --border: #3e3e42;
        --active-line: #2d2d30;
        --accent: #40a9ff;
        --toolbar-bg: #252526;
        --selection: #264f78;
        color-scheme: dark;
      }
    }

    body[data-theme="light"] {
      color-scheme: light;
    }

    body[data-theme="dark"] {
      --bg: #1e1e1e;
      --gutter-bg: #252526;
      --gutter-text: #858585;
      --text: #d4d4d4;
      --border: #3e3e42;
      --active-line: #2d2d30;
      --accent: #40a9ff;
      --toolbar-bg: #252526;
      --selection: #264f78;
      color-scheme: dark;
    }

    body[data-theme="sepia"] {
      --bg: #f7f2e7;
      --gutter-bg: #efe6d6;
      --gutter-text: #9b8f7a;
      --text: #3d3528;
      --border: #e0d6c5;
      --active-line: #f0e7d6;
      --accent: #9a6b32;
      --toolbar-bg: #efe6d6;
      --selection: #d8c7ad;
      color-scheme: light;
    }

    body[data-theme="nord"] {
      --bg: #2e3440;
      --gutter-bg: #3b4252;
      --gutter-text: #8f9bb3;
      --text: #eceff4;
      --border: #434c5e;
      --active-line: #3b4252;
      --accent: #88c0d0;
      --toolbar-bg: #3b4252;
      --selection: #4c566a;
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: "Menlo", "Monaco", "Courier New", monospace;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      overscroll-behavior: none;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px;
      background: var(--toolbar-bg);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
      flex-shrink: 0;
    }

    #toolbar::-webkit-scrollbar {
      display: none;
    }

    .btn {
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
    }

    .btn:active {
      opacity: 0.7;
    }

    .btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--active-line);
    }

    .btn.btn-icon {
      padding: 6px 8px;
      min-width: 28px;
    }

    #editor-container {
      position: relative;
      flex: 1;
      display: flex;
      min-height: 0;
      padding-bottom: env(safe-area-inset-bottom);
      overflow: hidden;
    }

    #editor {
      flex: 1;
      min-height: 0;
      min-width: 0;
      overflow: hidden;
    }

    .cm-editor {
      height: 100%;
    }

    .cm-panels.cm-panels-top {
      border-bottom: 1px solid var(--border);
      background: var(--toolbar-bg);
    }

    #format-options {
      position: absolute;
      top: 44px;
      right: 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      padding: 8px 10px;
      display: none;
      z-index: 30;
      font-size: 13px;
    }

    #format-options.show {
      display: block;
    }

    #format-options .opt {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }

    #format-options input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
    }

    #format-options select {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
    }

    #toast {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 20;
    }

    #toast.show {
      opacity: 1;
    }

    #log-panel {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 8px;
      max-height: 40%;
      display: none;
      flex-direction: column;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      z-index: 40;
      overflow: hidden;
    }

    #log-panel.show {
      display: flex;
    }

    #log-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
      background: var(--toolbar-bg);
      font-size: 12px;
    }

    #log-header .spacer {
      flex: 1;
    }

    #log-body {
      margin: 0;
      padding: 8px;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-all;
      overflow: auto;
      flex: 1;
    }

    #curl-panel {
      position: absolute;
      left: 8px;
      right: 8px;
      top: 44px;
      max-height: 60%;
      display: none;
      flex-direction: column;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      z-index: 45;
      overflow: hidden;
    }
    #curl-panel.show {
      display: flex;
    }
    #curl-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
      background: var(--toolbar-bg);
      font-size: 12px;
    }
    #curl-header .spacer {
      flex: 1;
    }
    #curl-header select {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
    }
    #curl-body {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      padding: 8px;
      overflow: auto;
      flex: 1;
    }
    .curl-text {
      min-height: 120px;
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      font-size: 12px;
      line-height: 1.4;
      background: var(--bg);
      color: var(--text);
      resize: none;
    }
  </style>
</head>

<body>
  <div id="toolbar">
    <button id="undoBtn" class="btn">Êí§ÈîÄ</button>
    <button id="redoBtn" class="btn">ÈáçÂÅö</button>
    <button id="wrapBtn" class="btn">Êç¢Ë°å</button>
    <button id="formatBtn" class="btn">Ê†ºÂºèÂåñ</button>
    <button id="formatOptionsBtn" class="btn btn-icon" title="Ê†ºÂºèÂåñÈÄâÈ°π">
      ‚ñæ
    </button>
    <button id="searchToggleBtn" class="btn">üîç</button>
    <button id="curlToggleBtn" class="btn">curl</button>
    <button id="logToggleBtn" class="btn">Êó•Âøó</button>
  </div>

  <div id="format-options">
    <label class="opt">
      <input id="wrapElementsToggle" type="checkbox" checked />
      <span>ÂÖÉÁ¥†Êç¢Ë°å</span>
    </label>
    <label class="opt">
      <span>Áº©Ëøõ</span>
      <select id="indentSizeSelect">
        <option value="2" selected>2</option>
        <option value="4">4</option>
      </select>
    </label>
    <label class="opt">
      <span>Â≠óÂè∑</span>
      <select id="fontSizeSelect">
        <option value="auto" selected>Ëá™Âä®</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="16">16</option>
      </select>
    </label>
    <label class="opt">
      <span>ÂÆΩÂ∫¶</span>
      <select id="printWidthSelect">
        <option value="80">80</option>
        <option value="120" selected>120</option>
        <option value="160">160</option>
      </select>
    </label>
    <label class="opt">
      <span>‰∏ªÈ¢ò</span>
      <select id="themeSelect">
        <option value="auto" selected>Á≥ªÁªü</option>
        <option value="light">ÊµÖËâ≤</option>
        <option value="dark">Ê∑±Ëâ≤</option>
        <option value="sepia">Êä§Áúº</option>
        <option value="nord">ÊûÅÂ§ú</option>
      </select>
    </label>
    <label class="opt">
      <input id="singleQuoteToggle" type="checkbox" />
      <span>ÂçïÂºïÂè∑</span>
    </label>
    <label class="opt">
      <input id="trailingCommaToggle" type="checkbox" checked />
      <span>Êú´Â∞æÈÄóÂè∑</span>
    </label>
  </div>

  <div id="log-panel">
    <div id="log-header">
      <span>Êó•Âøó</span>
      <span class="spacer"></span>
      <button id="logCopyBtn" class="btn btn-icon">Â§çÂà∂</button>
      <button id="logClearBtn" class="btn btn-icon">Ê∏ÖÁ©∫</button>
      <button id="logCloseBtn" class="btn btn-icon">√ó</button>
    </div>
    <pre id="log-body"></pre>
  </div>

  <div id="curl-panel">
    <div id="curl-header">
      <span>curl</span>
      <select id="curlModeSelect">
        <option value="curl-to-analyze">curl ‚Üí AnalyzeUrl</option>
        <option value="analyze-to-curl">AnalyzeUrl ‚Üí curl</option>
      </select>
      <span class="spacer"></span>
      <button id="curlConvertBtn" class="btn btn-icon">ËΩ¨Êç¢</button>
      <button id="curlCopyBtn" class="btn btn-icon">Â§çÂà∂</button>
      <button id="curlClearBtn" class="btn btn-icon">Ê∏ÖÁ©∫</button>
      <button id="curlCloseBtn" class="btn btn-icon">√ó</button>
    </div>
    <div id="curl-body">
      <textarea id="curl-input" class="curl-text" placeholder="Á≤òË¥¥ curl Êàñ AnalyzeUrl"></textarea>
      <textarea id="curl-output" class="curl-text" placeholder="ËΩ¨Êç¢ÁªìÊûú" readonly></textarea>
    </div>
  </div>

  <div id="editor-container">
    <div id="editor"></div>
  </div>

  <div id="toast"></div>

  <script>
    (function () {
      function bootError(msg) {
        var text = msg || "ÁºñËæëÂô®ÂàùÂßãÂåñÂ§±Ë¥•";
        var host = document.getElementById("editor");
        var toast = document.getElementById("toast");
        if (host) {
          host.textContent = text;
          host.style.padding = "12px";
          host.style.color = "var(--text)";
        }
        if (toast) {
          toast.textContent = text;
          toast.classList.add("show");
        }
      }
      window.__LEGADO_BOOT_ERROR = bootError;
      window.__LEGADO_EDITOR_BOOTED = false;

      function handleBootOrRuntimeError(kind, e) {
        if (window.__LEGADO_EDITOR_BOOTED) {
          if (typeof window.__LEGADO_RUNTIME_ERROR_HANDLER === "function") {
            window.__LEGADO_RUNTIME_ERROR_HANDLER(kind, e);
          }
          return;
        }
        var msg = "ÂèëÁîüÊú™Áü•ÈîôËØØ";
        if (kind === "promise") {
          msg =
            e && e.reason != null
              ? String(
                e.reason && e.reason.message ? e.reason.message : e.reason,
              )
              : msg;
        } else {
          msg = e && e.message ? e.message : msg;
        }
        bootError("ËÑöÊú¨ÈîôËØØÔºö" + msg);
      }

      window.addEventListener("error", function (e) {
        handleBootOrRuntimeError("error", e);
      });
      window.addEventListener("unhandledrejection", function (e) {
        handleBootOrRuntimeError("promise", e);
      });
    })();
  </script>

  <script src="standalone.min.js"></script>
  <script src="babel.js"></script>
  <script src="estree.js"></script>
  <script src="codemirror.bundle.js" onerror="
        window.__LEGADO_BOOT_ERROR &&
          window.__LEGADO_BOOT_ERROR('codemirror.bundle.js Âä†ËΩΩÂ§±Ë¥•')
      "></script>
  <script src="completions.js" onerror="
        window.__LEGADO_BOOT_ERROR &&
          window.__LEGADO_BOOT_ERROR('completions.js Âä†ËΩΩÂ§±Ë¥•')
      "></script>
  <script>
    // Êó©ÊúüÂÖúÂ∫ïÔºöÂ¶ÇÊûú‰∏ªËÑöÊú¨Êú™ÊâßË°åÔºåÊòæÁ§∫ÊèêÁ§∫
    window.setTimeout(function () {
      if (window.__LEGADO_EDITOR_BOOTED) return;
      if (window.__LEGADO_BOOT_ERROR) {
        window.__LEGADO_BOOT_ERROR(
          "ÁºñËæëÂô®ËÑöÊú¨Êú™ÊâßË°åÔºåËØ∑Á°ÆËÆ§ codemirror.bundle.js Â∑≤Êõ¥Êñ∞Âπ∂ÈáçÊñ∞ÂÆâË£Ö APK„ÄÇ",
        );
      }
    }, 1200);
  </script>
  <script>
    (function () {
      try {
        const $ = (id) => document.getElementById(id);
        const bootError = window.__LEGADO_BOOT_ERROR || function () { };
        const LOG_MAX = 200;
        const SETTINGS_KEY = "legado.codeEditor.formatSettings";
        const TOAST_MS = 1500;
        const LONG_LINE_SCROLL_LIMIT = 2000;

        const dom = {
          editorHost: $("editor"),
          toast: $("toast"),
          logPanel: $("log-panel"),
          logBody: $("log-body"),
          curlPanel: $("curl-panel"),
          curlInput: $("curl-input"),
          curlOutput: $("curl-output"),
          curlModeSelect: $("curlModeSelect"),
          undoBtn: $("undoBtn"),
          redoBtn: $("redoBtn"),
          wrapBtn: $("wrapBtn"),
          formatBtn: $("formatBtn"),
          formatOptionsBtn: $("formatOptionsBtn"),
          searchToggleBtn: $("searchToggleBtn"),
          curlToggleBtn: $("curlToggleBtn"),
          logToggleBtn: $("logToggleBtn"),
          logCloseBtn: $("logCloseBtn"),
          logCopyBtn: $("logCopyBtn"),
          logClearBtn: $("logClearBtn"),
          curlConvertBtn: $("curlConvertBtn"),
          curlCopyBtn: $("curlCopyBtn"),
          curlClearBtn: $("curlClearBtn"),
          curlCloseBtn: $("curlCloseBtn"),
          wrapElementsToggle: $("wrapElementsToggle"),
          indentSizeSelect: $("indentSizeSelect"),
          fontSizeSelect: $("fontSizeSelect"),
          printWidthSelect: $("printWidthSelect"),
          themeSelect: $("themeSelect"),
          singleQuoteToggle: $("singleQuoteToggle"),
          trailingCommaToggle: $("trailingCommaToggle"),
          formatOptions: $("format-options"),
        };

        const CM = window.CodeMirrorBundle;
        if (!CM || !CM.EditorView) {
          bootError(
            "CodeMirror Êú™Âä†ËΩΩÔºåËØ∑Á°ÆËÆ§ codemirror.bundle.js Â∑≤ÊâìÂåÖÂπ∂ÂèØËÆøÈóÆ",
          );
          return;
        }

        const {
          EditorState,
          Compartment,
          EditorView,
          keymap,
          lineNumbers,
          highlightActiveLineGutter,
          history,
          undo,
          redo,
          indentOnInput,
          bracketMatching,
          syntaxHighlighting,
          defaultHighlightStyle,
          indentUnit,
          foldGutter,
          highlightSelectionMatches,
          openSearchPanel,
          autocompletion,
          closeCompletion,
          closeBrackets,
          closeBracketsKeymap,
          javascript,
          indentMore,
          indentLess,
          insertNewlineAndIndent,
          Transaction,
        } = CM;

        let isWrap = false;
        let wrapElements = true;
        let tabSize = 2;
        let fontSize = "auto";
        let printWidth = 120;
        let singleQuote = false;
        let trailingComma = true;
        let themeMode = "auto";
        let logLines = [];
        let isLogOpen = false;
        let lastAppliedPixelSize = 0;

        function appendLog(level, msg) {
          const time = new Date()
            .toISOString()
            .replace("T", " ")
            .replace("Z", "");
          const text = String(msg == null ? "" : msg);
          const line = `[${time}] ${level}: ${text.length > 1000 ? text.slice(0, 1000) + "‚Ä¶" : text}`;
          logLines.push(line);
          if (logLines.length > LOG_MAX) logLines.shift();
          if (isLogOpen && dom.logBody) {
            dom.logBody.textContent = logLines.join("\n");
            dom.logBody.scrollTop = dom.logBody.scrollHeight;
          }
        }

        function loadSettings() {
          try {
            const raw = window.localStorage
              ? window.localStorage.getItem(SETTINGS_KEY)
              : null;
            if (!raw) return;
            const data = JSON.parse(raw);
            if (data && typeof data === "object") {
              if (typeof data.isWrap === "boolean") isWrap = data.isWrap;
              if (typeof data.wrapElements === "boolean")
                wrapElements = data.wrapElements;
              if (data.tabSize != null)
                tabSize = parseInt(data.tabSize, 10) || tabSize;
              if (data.fontSize != null) fontSize = String(data.fontSize);
              if (data.printWidth != null)
                printWidth = parseInt(data.printWidth, 10) || printWidth;
              if (typeof data.singleQuote === "boolean")
                singleQuote = data.singleQuote;
              if (typeof data.trailingComma === "boolean")
                trailingComma = data.trailingComma;
              if (typeof data.themeMode === "string")
                themeMode = data.themeMode;
            }
          } catch (e) {
            appendLog(
              "error",
              "ËÆæÁΩÆËØªÂèñÂ§±Ë¥•: " + (e && e.message ? e.message : e),
            );
          }
        }

        function saveSettings() {
          try {
            if (!window.localStorage) return;
            const data = {
              isWrap,
              wrapElements,
              tabSize,
              fontSize,
              printWidth,
              singleQuote,
              trailingComma,
              themeMode,
            };
            window.localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
          } catch (e) {
            appendLog(
              "error",
              "ËÆæÁΩÆ‰øùÂ≠òÂ§±Ë¥•: " + (e && e.message ? e.message : e),
            );
          }
        }

        const wrapComp = new Compartment();
        const themeComp = new Compartment();
        const fontComp = new Compartment();
        const indentComp = new Compartment();
        const mediaDark = window.matchMedia
          ? window.matchMedia("(prefers-color-scheme: dark)")
          : null;

        function isDarkTheme() {
          if (themeMode === "auto") return !!(mediaDark && mediaDark.matches);
          return themeMode === "dark" || themeMode === "nord";
        }

        function getSystemFontSize() {
          const size = parseFloat(
            window.getComputedStyle(document.body).fontSize,
          );
          return isNaN(size) ? 13 : size;
        }

        function makeFontTheme() {
          const px =
            fontSize === "auto"
              ? getSystemFontSize()
              : parseInt(fontSize, 10) || 13;
          return EditorView.theme({
            ".cm-scroller": {
              fontSize: px + "px",
            },
            ".cm-gutters": { fontSize: px + "px" },
          });
        }

        function makeTheme() {
          return EditorView.theme(
            {
              "&": {
                height: "100%",
                backgroundColor: "var(--bg)",
                color: "var(--text)",
                "-webkit-tap-highlight-color": "transparent",
              },
              ".cm-scroller": {
                fontFamily: "inherit",
                lineHeight: "1.5",
                overflow: "auto",
                "-webkit-overflow-scrolling": "touch",
                overflowAnchor: "none",
              },
              ".cm-content": {
                padding: "10px",
                maxWidth: "100%",
                overflowWrap: "anywhere",
              },
              ".cm-gutters": {
                backgroundColor: "var(--gutter-bg)",
                color: "var(--gutter-text)",
                borderRight: "1px solid var(--border)",
              },
              ".cm-activeLine": { backgroundColor: "var(--active-line)" },
              ".cm-selectionBackground": {
                backgroundColor: "var(--selection)",
              },
            },
            { dark: isDarkTheme() },
          );
        }

        function applyTheme(mode) {
          themeMode = mode || "auto";
          if (themeMode === "auto") {
            document.body.removeAttribute("data-theme");
          } else {
            document.body.setAttribute("data-theme", themeMode);
          }
          if (view) {
            view.dispatch({ effects: themeComp.reconfigure(makeTheme()) });
          }
        }

        function applyTabSize(size) {
          tabSize = size;
          if (view) {
            view.dispatch({
              effects: indentComp.reconfigure(
                indentUnit.of(" ".repeat(tabSize)),
              ),
            });
          }
        }

        function applyFontSize(size) {
          fontSize = size;
          const px = fontSize === "auto" ? getSystemFontSize() : (parseInt(fontSize, 10) || 13);
          if (view && Math.abs(px - lastAppliedPixelSize) < 0.1) {
            return;
          }
          lastAppliedPixelSize = px;
          if (view) {
            view.dispatch({ effects: fontComp.reconfigure(makeFontTheme()) });
          }
        }

        function insertTab(view) {
          if (indentMore && !view.state.selection.main.empty) {
            return indentMore(view);
          }
          view.dispatch(view.state.replaceSelection(" ".repeat(tabSize)));
          return true;
        }

        function insertNewlineClamped(view) {
          const { state } = view;
          const { from, to, head } = state.selection.main;
          const line = state.doc.lineAt(head);
          if (
            line.length < LONG_LINE_SCROLL_LIMIT &&
            typeof insertNewlineAndIndent === "function"
          ) {
            return insertNewlineAndIndent(view);
          }
          let baseIndent = (line.text.match(/^\s*/) || [""])[0];
          const insert = "\n" + baseIndent;
          const cursor = from + insert.length;
          view.dispatch({
            changes: { from, to, insert },
            selection: { anchor: cursor, head: cursor },
            effects: EditorView.scrollIntoView(cursor, { y: "nearest" }),
          });
          const target = cursor;
          const editorView = view;
          view.requestMeasure({
            read(view) {
              const coords = view.coordsAtPos(target);
              const rect = view.scrollDOM.getBoundingClientRect();
              return {
                coords,
                rect,
                scrollTop: view.scrollDOM.scrollTop,
              };
            },
            write(view, data) {
              const lineLen = editorView.state.doc.lineAt(target).length;
              if (!data || !data.coords) {
                if (lineLen >= LONG_LINE_SCROLL_LIMIT) {
                  requestAnimationFrame(() => {
                    editorView.scrollDOM.scrollTop =
                      editorView.scrollDOM.scrollHeight;
                  });
                } else {
                  requestAnimationFrame(() => {
                    editorView.dispatch({
                      effects: EditorView.scrollIntoView(target, {
                        y: "nearest",
                      }),
                    });
                  });
                }
                return;
              }
              const { coords, rect } = data;
              if (coords.top < rect.top || coords.bottom > rect.bottom) {
                requestAnimationFrame(() => {
                  editorView.dispatch({
                    effects: EditorView.scrollIntoView(target, {
                      y: "nearest",
                    }),
                  });
                });
              }
            },
          });
          return true;
        }

        

        const CUSTOM_COMPLETIONS =
          window.CUSTOM_COMPLETIONS &&
            typeof window.CUSTOM_COMPLETIONS === "object"
            ? window.CUSTOM_COMPLETIONS
            : {};
        const completionRegex = (() => {
          const keys = Object.keys(CUSTOM_COMPLETIONS);
          return keys.length
            ? new RegExp(`^(${keys.join("|")})\\.([\\w]*)$`)
            : null;
        })();

        function customCompletion(context) {
          if (!context.explicit) {
            const prev =
              context.pos > 0
                ? context.state.sliceDoc(context.pos - 1, context.pos)
                : "";
            if (prev.trim() === "") return null;
          }
          const word = context.matchBefore(/[\w$.]+$/);
          if (!word) return null;
          if (!context.explicit && word.from === word.to) return null;
          if (!completionRegex) return null;
          const m = word.text.match(completionRegex);
          if (!m) return null;
          const base = m[1];
          const prefix = m[2] || "";
          const entry = CUSTOM_COMPLETIONS[base] || {
            methods: [],
            props: [],
          };
          const props = (entry.props || [])
            .filter(
              (label) =>
                typeof label === "string" && label.startsWith(prefix),
            )
            .map((label) => ({ label, type: "property", detail: base }));
          const methods = (entry.methods || [])
            .filter(
              (label) =>
                typeof label === "string" && label.startsWith(prefix),
            )
            .map((label) => {
              const hasParen = label.endsWith("()");
              const insertText = hasParen ? label : label + "()";
              return {
                label,
                type: "function",
                detail: base,
                apply: (view, completion, from, to) => {
                  const anchor = hasParen
                    ? from + insertText.length
                    : from + insertText.length - 1;
                  view.dispatch({
                    changes: { from, to, insert: insertText },
                    selection: { anchor, head: anchor },
                  });
                },
              };
            });
          const options = props.concat(methods);
          if (!options.length) return null;
          return {
            from: word.from + base.length + 1,
            options,
            validFor: /^\w*$/,
          };
        }

        function tokenizeCurl(cmd) {
          const tokens = [];
          let cur = "";
          let quote = "";
          let i = 0;

          function pushCur() {
            if (cur) tokens.push(cur);
            cur = "";
          }

          while (i < cmd.length) {
            const ch = cmd[i];
            if (quote) {
              if (ch === "\\") {
                if (i + 1 < cmd.length) {
                  cur += cmd[i + 1];
                  i += 2;
                  continue;
                }
              }
              if (ch === quote) {
                quote = "";
                i += 1;
                continue;
              }
              cur += ch;
              i += 1;
              continue;
            }

            if (ch === "'" || ch === "\"") {
              quote = ch;
              i += 1;
              continue;
            }

            if (/\s/.test(ch)) {
              pushCur();
              i += 1;
              continue;
            }

            if (ch === "\\" && i + 1 < cmd.length) {
              cur += cmd[i + 1];
              i += 2;
              continue;
            }

            cur += ch;
            i += 1;
          }
          pushCur();
          return tokens;
        }

        function parseCurl(cmd) {
          const tokens = tokenizeCurl(cmd || "");
          let method = "";
          const headers = {};
          const dataParts = [];
          let url = "";
          let cookie = "";

          function takeValue(i) {
            return i + 1 < tokens.length ? tokens[i + 1] : "";
          }

          for (let i = 0; i < tokens.length; i += 1) {
            const t = tokens[i];
            if (t === "curl") continue;

            if (t === "-X" || t === "--request") {
              method = takeValue(i).toUpperCase();
              i += 1;
              continue;
            }

            if (t === "-H" || t === "--header") {
              const h = takeValue(i);
              i += 1;
              const idx = h.indexOf(":");
              if (idx > 0) {
                headers[h.slice(0, idx).trim()] = h.slice(idx + 1).trim();
              }
              continue;
            }

            if (t.indexOf("-H") === 0 && t.length > 2) {
              const hv = t.slice(2);
              const hidx = hv.indexOf(":");
              if (hidx > 0) {
                headers[hv.slice(0, hidx).trim()] = hv.slice(hidx + 1).trim();
              }
              continue;
            }

            if (
              t === "-d" ||
              t === "--data" ||
              t === "--data-raw" ||
              t === "--data-binary" ||
              t === "--data-urlencode"
            ) {
              dataParts.push(takeValue(i));
              if (!method) method = "POST";
              i += 1;
              continue;
            }

            if (
              t.indexOf("--data=") === 0 ||
              t.indexOf("--data-raw=") === 0 ||
              t.indexOf("--data-binary=") === 0 ||
              t.indexOf("--data-urlencode=") === 0
            ) {
              dataParts.push(t.split("=", 2)[1] || "");
              if (!method) method = "POST";
              continue;
            }

            if (t === "-b" || t === "--cookie") {
              cookie = takeValue(i);
              i += 1;
              continue;
            }

            if (t.indexOf("--cookie=") === 0) {
              cookie = t.split("=", 2)[1] || "";
              continue;
            }

            if (t.indexOf("http://") === 0 || t.indexOf("https://") === 0) {
              url = t;
              continue;
            }

            if (t[0] !== "-" && !url) {
              url = t;
            }
          }

          if (cookie && !headers.Cookie) {
            headers.Cookie = cookie;
          }

          return {
            url,
            method,
            headers,
            body: dataParts.join("&"),
          };
        }

        function shellQuote(value) {
          const str = String(value == null ? "" : value);
          if (!/[\s'"\\]/.test(str)) return str;
          return "'" + str.replace(/'/g, "'\"'\"'") + "'";
        }

        function curlToAnalyzeUrl(cmd) {
          const parsed = parseCurl(cmd);
          if (!parsed.url) {
            throw new Error("Êú™Ëß£ÊûêÂà∞ URL");
          }
          const options = {};
          const method = parsed.method || "";
          if (method && (method !== "GET" || parsed.body)) {
            options.method = method;
          }
          if (parsed.body) options.body = parsed.body;
          if (parsed.headers && Object.keys(parsed.headers).length) {
            options.headers = parsed.headers;
          }
          const hasOptions = Object.keys(options).length > 0;
          return hasOptions
            ? `${parsed.url},${JSON.stringify(options)}`
            : parsed.url;
        }

        function splitAnalyzeUrl(text) {
          const raw = String(text || "").trim();
          if (!raw) return { url: "", options: null };
          const braceIdx = raw.indexOf("{");
          if (braceIdx === -1) return { url: raw, options: null };
          const commaIdx = raw.lastIndexOf(",", braceIdx);
          if (commaIdx === -1) return { url: raw, options: null };
          const url = raw.slice(0, commaIdx).trim();
          const json = raw.slice(commaIdx + 1).trim();
          return { url, options: json };
        }

        function analyzeUrlToCurl(text) {
          const parsed = splitAnalyzeUrl(text);
          const url = parsed.url;
          if (!url) throw new Error("Êú™Ëß£ÊûêÂà∞ URL");
          let options = {};
          if (parsed.options) {
            options = JSON.parse(parsed.options);
          }
          const method = options.method
            ? String(options.method).toUpperCase()
            : "";
          const headers =
            options.headers && typeof options.headers === "object"
              ? options.headers
              : {};
          const body = options.body != null ? options.body : "";
          const parts = ["curl", shellQuote(url)];
          if (method && method !== "GET") {
            parts.push("-X", method);
          }
          Object.keys(headers).forEach((key) => {
            parts.push("-H", shellQuote(`${key}: ${headers[key]}`));
          });
          if (body !== "") {
            const payload =
              typeof body === "string" ? body : JSON.stringify(body);
            parts.push("--data-raw", shellQuote(payload));
          }
          return parts.join(" ");
        }

        function buildAutocompleteExtensions() {
          if (!autocompletion) return [];
          return [
            autocompletion({
              activateOnTyping: true,
              maxRenderedOptions: 200,
            }),
          ];
        }
        function buildExtensions() {
          const tabKey = {
            key: "Tab",
            run: insertTab,
            shift: indentLess || undefined,
          };
          const enterKey = { key: "Enter", run: insertNewlineClamped };
          const closeKeymap = Array.isArray(closeBracketsKeymap)
            ? closeBracketsKeymap
            : closeBracketsKeymap
              ? [closeBracketsKeymap]
              : [];
          const exts = [];
          if (typeof history === "function") exts.push(history());
          if (keymap && typeof keymap.of === "function") {
            const km = [tabKey, ...closeKeymap];
            if (enterKey) km.unshift(enterKey);
            exts.push(keymap.of(km));
          }
          if (typeof lineNumbers === "function") exts.push(lineNumbers());
          if (typeof highlightActiveLineGutter === "function")
            exts.push(highlightActiveLineGutter());
          if (typeof foldGutter === "function") exts.push(foldGutter());
          if (wrapComp && EditorView && EditorView.lineWrapping)
            exts.push(wrapComp.of(isWrap ? EditorView.lineWrapping : []));
          if (
            indentComp &&
            indentUnit &&
            typeof indentUnit.of === "function"
          ) {
            exts.push(indentComp.of(indentUnit.of(" ".repeat(tabSize))));
          }
          if (typeof javascript === "function") exts.push(javascript());
          if (typeof indentOnInput === "function") exts.push(indentOnInput());
          if (typeof closeBrackets === "function") exts.push(closeBrackets());
          if (typeof bracketMatching === "function")
            exts.push(bracketMatching());
          if (typeof syntaxHighlighting === "function") {
            exts.push(
              syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
            );
          }
          if (typeof highlightSelectionMatches === "function")
            exts.push(highlightSelectionMatches());
          if (typeof closeCompletion === "function") {
            exts.push(
              EditorView.updateListener.of((update) => {
                if (!update.docChanged) return;
                const isDelete = update.transactions.some(
                  (t) =>
                    t.isUserEvent &&
                    (t.isUserEvent("delete") ||
                      t.isUserEvent("delete.backward") ||
                      t.isUserEvent("delete.forward")),
                );
                if (isDelete) closeCompletion(update.view);
              }),
            );
          }
          if (
            EditorState &&
            EditorState.languageData &&
            typeof EditorState.languageData.of === "function"
          ) {
            exts.push(
              EditorState.languageData.of((state, pos, side) => [
                { autocomplete: customCompletion },
              ]),
            );
          }
          exts.push(...buildAutocompleteExtensions());
          if (themeComp) exts.push(themeComp.of(makeTheme()));
          if (fontComp) exts.push(fontComp.of(makeFontTheme()));
          return exts;
        }

        loadSettings();

        let view;
        try {
          view = new EditorView({
            state: EditorState.create({
              doc: "",
              extensions: buildExtensions(),
            }),
            parent: dom.editorHost,
          });
          const focusNoScroll = () => {
            if (!view || !view.contentDOM) return;
            if (typeof view.contentDOM.focus !== "function") return;
            try {
              view.contentDOM.focus({ preventScroll: true });
            } catch (e) {
              view.contentDOM.focus();
            }
          };
          dom.editorHost.addEventListener("pointerdown", focusNoScroll, {
            capture: true,
            passive: true,
          });
          dom.editorHost.addEventListener("touchstart", focusNoScroll, {
            capture: true,
            passive: true,
          });
          applyTabSize(tabSize);
          applyFontSize(fontSize);
          applyTheme(themeMode);
        } catch (e) {
          appendLog("error", e && e.message ? e.message : e);
          bootError("ÁºñËæëÂô®ÂàùÂßãÂåñÂ§±Ë¥•: " + (e && e.message ? e.message : e));
          return;
        }
        window.__LEGADO_EDITOR_BOOTED = true;

        const syncAutoTheme = () => {
          if (themeMode !== "auto") return;
          view.dispatch({ effects: themeComp.reconfigure(makeTheme()) });
        };
        if (mediaDark) {
          if (typeof mediaDark.addEventListener === "function") {
            mediaDark.addEventListener("change", syncAutoTheme);
          } else if (typeof mediaDark.addListener === "function") {
            mediaDark.addListener(syncAutoTheme);
          }
        }

        function getCode() {
          return view.state.doc.toString();
        }

        function resetDoc(text, opts) {
          const doc = text || "";
          const len = view.state.doc.length;
          const addToHistory = !(opts && opts.addToHistory === false);
          const tr = {
            changes: { from: 0, to: len, insert: doc },
          };
          if (!addToHistory && Transaction && Transaction.addToHistory) {
            tr.annotations = Transaction.addToHistory.of(false);
          }
          view.dispatch(tr);
        }

        function detectWrapper(rawText) {
          const raw = rawText || "";
          const trimmed = raw.trim();
          const jsPrefixMatch = raw.match(/^\s*@js:\s*[\r\n]?([\s\S]*)$/);
          if (jsPrefixMatch) {
            return {
              type: "prefix",
              prefix: "@js:",
              body: jsPrefixMatch[1] || "",
            };
          }
          const tagMatch = trimmed.match(/^<js>\s*([\s\S]*?)\s*<\/js>$/i);
          if (tagMatch) {
            return {
              type: "tag",
              open: "<js>",
              close: "</js>",
              body: tagMatch[1],
            };
          }
          const braceMatch = trimmed.match(/^\{\{\s*([\s\S]*?)\s*\}\}$/);
          if (braceMatch) {
            return { type: "moustache", body: braceMatch[1] };
          }
          return null;
        }

        let prettierPluginsCache = null;
        function getPrettierPlugins() {
          if (prettierPluginsCache) return prettierPluginsCache;
          if (!window.prettierPlugins) return null;
          const list = [];
          if (window.prettierPlugins.babel)
            list.push(window.prettierPlugins.babel);
          if (window.prettierPlugins.estree)
            list.push(window.prettierPlugins.estree);
          prettierPluginsCache = list.length ? list : null;
          return prettierPluginsCache;
        }

        async function formatWithPrettier(codeText, parser) {
          if (!window.prettier || !window.prettierPlugins) {
            throw new Error("Prettier Êú™Âä†ËΩΩ");
          }
          const plugins = getPrettierPlugins();
          if (!plugins || !plugins.length) {
            throw new Error("Prettier Êèí‰ª∂Êú™Âä†ËΩΩ");
          }
          const width = wrapElements
            ? printWidth
            : Math.max(printWidth, 99999);
          return window.prettier.format(codeText, {
            parser: parser || "babel",
            plugins: plugins,
            tabWidth: tabSize,
            useTabs: false,
            singleQuote: singleQuote,
            trailingComma: trailingComma ? "es5" : "none",
            printWidth: width,
          });
        }

        async function formatCode() {
          const raw = getCode();
          const text = raw.trim();
          if (!text) return;
          showToast("Ê†ºÂºèÂåñ‰∏≠...");
          await new Promise(requestAnimationFrame);
          try {
            const wrapper = detectWrapper(raw);
            let formattedBody = "";
            if (wrapper) {
              formattedBody = await formatWithPrettier(wrapper.body, "babel");
              if (wrapper.type === "prefix") {
                formattedBody = wrapper.prefix + "\n" + formattedBody;
              } else if (wrapper.type === "tag") {
                formattedBody =
                  wrapper.open + "\n" + formattedBody + "\n" + wrapper.close;
              } else if (wrapper.type === "moustache") {
                formattedBody = "{{\n" + formattedBody + "\n}}";
              }
            } else {
              if (/^[\[{]/.test(text)) {
                try {
                  formattedBody = JSON.stringify(
                    JSON.parse(text),
                    null,
                    " ".repeat(tabSize),
                  );
                } catch (e) {
                  formattedBody = "";
                }
              }
              if (!formattedBody) {
                formattedBody = await formatWithPrettier(text, "babel");
              }
            }
            resetDoc(formattedBody);
            showToast("Ê†ºÂºèÂåñÂÆåÊàê");
          } catch (e) {
            appendLog("error", e && e.message ? e.message : e);
            showToast("Ê†ºÂºèÂåñÂ§±Ë¥•");
          }
        }

        bindClick(dom.undoBtn, () => undo(view));
        bindClick(dom.redoBtn, () => redo(view));
        bindClick(dom.formatBtn, formatCode);

        const wrapBtn = dom.wrapBtn;
        bindClick(wrapBtn, () => {
          isWrap = !isWrap;
          view.dispatch({
            effects: wrapComp.reconfigure(
              isWrap ? EditorView.lineWrapping : [],
            ),
          });
          wrapBtn.classList.toggle("active", isWrap);
          saveSettings();
          showToast("Ëá™Âä®Êç¢Ë°å: " + (isWrap ? "ÂºÄ" : "ÂÖ≥"));
        });
        const formatOptionsBtn = dom.formatOptionsBtn;
        const formatOptions = dom.formatOptions;
        const wrapElementsToggle = dom.wrapElementsToggle;
        const indentSizeSelect = dom.indentSizeSelect;
        const fontSizeSelect = dom.fontSizeSelect;
        const printWidthSelect = dom.printWidthSelect;
        const themeSelect = dom.themeSelect;
        const singleQuoteToggle = dom.singleQuoteToggle;
        const trailingCommaToggle = dom.trailingCommaToggle;

        wrapElementsToggle.checked = wrapElements;
        indentSizeSelect.value = String(tabSize);
        fontSizeSelect.value = String(fontSize);
        printWidthSelect.value = String(printWidth);
        themeSelect.value = String(themeMode);
        singleQuoteToggle.checked = singleQuote;
        trailingCommaToggle.checked = trailingComma;

        function bindToggle(el, onChange, labelFn) {
          el.addEventListener("change", () => {
            onChange(el.checked);
            if (labelFn) showToast(labelFn());
            saveSettings();
          });
        }

        function bindSelect(el, onChange, labelFn) {
          el.addEventListener("change", () => {
            onChange(el.value);
            if (labelFn) showToast(labelFn());
            saveSettings();
          });
        }

        bindToggle(
          wrapElementsToggle,
          (val) => {
            wrapElements = val;
          },
          () => "ÂÖÉÁ¥†Êç¢Ë°å: " + (wrapElements ? "ÂºÄ" : "ÂÖ≥"),
        );
        bindSelect(
          indentSizeSelect,
          (val) => applyTabSize(parseInt(val, 10) || 2),
          () => "Áº©Ëøõ: " + tabSize,
        );
        bindSelect(
          fontSizeSelect,
          (val) => applyFontSize(val || "auto"),
          () => "Â≠óÂè∑: " + (fontSize === "auto" ? "Ëá™Âä®" : fontSize),
        );
        bindSelect(
          printWidthSelect,
          (val) => {
            printWidth = parseInt(val, 10) || 120;
          },
          () => "ÂÆΩÂ∫¶: " + printWidth,
        );
        bindSelect(
          themeSelect,
          (val) => applyTheme(val || "auto"),
          () => "‰∏ªÈ¢ò: " + (themeMode === "auto" ? "Á≥ªÁªü" : themeMode),
        );
        bindToggle(
          singleQuoteToggle,
          (val) => {
            singleQuote = val;
          },
          () => "ÂçïÂºïÂè∑: " + (singleQuote ? "ÂºÄ" : "ÂÖ≥"),
        );
        bindToggle(
          trailingCommaToggle,
          (val) => {
            trailingComma = val;
          },
          () => "Êú´Â∞æÈÄóÂè∑: " + (trailingComma ? "ÂºÄ" : "ÂÖ≥"),
        );

        bindClick(formatOptionsBtn, () => {
          formatOptions.classList.toggle("show");
        });
        document.addEventListener("click", (e) => {
          if (!formatOptions.classList.contains("show")) return;
          const target = e.target;
          if (
            (target instanceof Element && target.closest("#format-options")) ||
            (target instanceof Element && target.closest("#formatOptionsBtn"))
          ) {
            return;
          }
          formatOptions.classList.remove("show");
        });

        bindClick(dom.searchToggleBtn, () => {
          if (typeof openSearchPanel === "function") {
            openSearchPanel(view);
            requestAnimationFrame(() => {
              bindSearchPanelHandlers();
              focusSearchInput();
            });
          } else {
            showToast("ÊêúÁ¥¢Ê®°ÂùóÊú™Âä†ËΩΩ");
          }
        });

        function focusSearchInput() {
          const panel = view && view.dom ? view.dom.querySelector(".cm-search") : null;
          if (!panel) return false;
          const input = panel.querySelector("input");
          if (!input) return false;
          try {
            input.focus({ preventScroll: true });
          } catch (e) {
            input.focus();
          }
          return true;
        }

        function bindSearchPanelHandlers() {
          const panel = view && view.dom ? view.dom.querySelector(".cm-search") : null;
          if (!panel || panel.dataset.focusGuard === "1") return;
          panel.dataset.focusGuard = "1";
          const guard = (e) => {
            const target = e.target instanceof Element ? e.target : null;
            if (target && target.closest("button")) {
              setTimeout(focusSearchInput, 0);
            }
          };
          panel.addEventListener("pointerdown", guard, true);
          panel.addEventListener("touchstart", guard, true);
          panel.addEventListener("mousedown", guard, true);
          panel.addEventListener("click", () => {
            focusSearchInput();
          }, true);
        }

        function bindClick(el, handler) {
          el.onclick = handler;
        }

        function updateCurlPlaceholders() {
          if (!dom.curlInput || !dom.curlOutput || !dom.curlModeSelect) return;
          if (dom.curlModeSelect.value === "analyze-to-curl") {
            dom.curlInput.placeholder = "Á≤òË¥¥ AnalyzeUrl";
            dom.curlOutput.placeholder = "ËΩ¨Êç¢ÂêéÁöÑ curl";
          } else {
            dom.curlInput.placeholder = "Á≤òË¥¥ curl";
            dom.curlOutput.placeholder = "ËΩ¨Êç¢ÂêéÁöÑ AnalyzeUrl";
          }
        }

        if (dom.curlModeSelect) {
          dom.curlModeSelect.addEventListener("change", updateCurlPlaceholders);
          updateCurlPlaceholders();
        }

        bindClick(dom.curlToggleBtn, () => {
          dom.curlPanel.classList.toggle("show");
          if (dom.curlPanel.classList.contains("show")) {
            updateCurlPlaceholders();
            if (dom.curlInput) dom.curlInput.focus();
          }
        });
        bindClick(dom.curlCloseBtn, () => {
          dom.curlPanel.classList.remove("show");
        });
        bindClick(dom.curlClearBtn, () => {
          if (dom.curlInput) dom.curlInput.value = "";
          if (dom.curlOutput) dom.curlOutput.value = "";
        });
        bindClick(dom.curlConvertBtn, () => {
          const input = dom.curlInput ? dom.curlInput.value : "";
          if (!input.trim()) {
            showToast("ËØ∑ËæìÂÖ•ÂÜÖÂÆπ");
            return;
          }
          try {
            const mode = dom.curlModeSelect
              ? dom.curlModeSelect.value
              : "curl-to-analyze";
            const output =
              mode === "analyze-to-curl"
                ? analyzeUrlToCurl(input)
                : curlToAnalyzeUrl(input);
            if (dom.curlOutput) dom.curlOutput.value = output;
          } catch (e) {
            appendLog(
              "error",
              "ËΩ¨Êç¢Â§±Ë¥•: " + (e && e.message ? e.message : e),
            );
            showToast("ËΩ¨Êç¢Â§±Ë¥•");
          }
        });
        bindClick(dom.curlCopyBtn, async () => {
          const text = dom.curlOutput ? dom.curlOutput.value : "";
          if (!text) {
            showToast("Ê≤°ÊúâÂèØÂ§çÂà∂ÂÜÖÂÆπ");
            return;
          }
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
            } else {
              const ta = document.createElement("textarea");
              ta.value = text;
              ta.style.position = "fixed";
              ta.style.left = "-9999px";
              document.body.appendChild(ta);
              ta.select();
              document.execCommand("copy");
              document.body.removeChild(ta);
            }
            showToast("Â∑≤Â§çÂà∂");
          } catch (e) {
            appendLog(
              "error",
              "Â§çÂà∂Â§±Ë¥•: " + (e && e.message ? e.message : e),
            );
            showToast("Â§çÂà∂Â§±Ë¥•");
          }
        });

        bindClick(dom.logToggleBtn, () => {
          dom.logPanel.classList.toggle("show");
          isLogOpen = dom.logPanel.classList.contains("show");
          if (isLogOpen && dom.logBody) {
            dom.logBody.textContent = logLines.join("\n");
            dom.logBody.scrollTop = dom.logBody.scrollHeight;
          }
        });
        bindClick(dom.logCloseBtn, () => {
          dom.logPanel.classList.remove("show");
          isLogOpen = false;
        });
        bindClick(dom.logCopyBtn, async () => {
          const text = logLines.join("\n");
          if (!text) {
            showToast("Êó•Âøó‰∏∫Á©∫");
            return;
          }
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
            } else {
              const ta = document.createElement("textarea");
              ta.value = text;
              ta.style.position = "fixed";
              ta.style.left = "-9999px";
              document.body.appendChild(ta);
              ta.select();
              document.execCommand("copy");
              document.body.removeChild(ta);
            }
            showToast("Êó•ÂøóÂ∑≤Â§çÂà∂");
          } catch (e) {
            appendLog("error", "Â§çÂà∂Â§±Ë¥•: " + (e && e.message ? e.message : e));
            showToast("Â§çÂà∂Â§±Ë¥•");
          }
        });
        bindClick(dom.logClearBtn, () => {
          logLines = [];
          if (isLogOpen && dom.logBody) dom.logBody.textContent = "";
        });

        let toastTimer = null;
        function showToast(msg) {
          dom.toast.textContent = msg;
          dom.toast.classList.add("show");
          clearTimeout(toastTimer);
          toastTimer = setTimeout(
            () => dom.toast.classList.remove("show"),
            TOAST_MS,
          );
        }

        function b64ToUtf8(b64) {
          try {
            const bin = window.atob(b64);
            if (window.TextDecoder) {
              const bytes = Uint8Array.from(bin, (c) => c.charCodeAt(0));
              return new TextDecoder("utf-8").decode(bytes);
            }
            return decodeURIComponent(escape(bin));
          } catch (e) {
            return "";
          }
        }

        window.__LEGADO_RUNTIME_ERROR_HANDLER = function (kind, e) {
          const unknown = "ÂèëÁîüÊú™Áü•ÈîôËØØ";
          let msg = unknown;
          let stack = "";

          if (kind === "promise") {
            const r = e && e.reason != null ? e.reason : unknown;
            msg =
              typeof r === "string"
                ? r
                : r && r.message
                  ? r.message
                  : String(r);
            stack = r && r.stack ? String(r.stack) : "";
          } else {
            msg = e && e.message ? e.message : unknown;
            stack =
              e && e.error && e.error.stack ? String(e.error.stack) : "";
          }

          appendLog(kind, msg + (stack ? "\n" + stack : ""));
          showToast("ÂèëÁîüÈîôËØØÔºö" + msg);
        };

        window.setCodeFromAndroid = function (b64) {
          resetDoc(b64ToUtf8(b64), { addToHistory: false });
        };

        window.__save = function () {
          const val = getCode();
          if (window.Android && window.Android.save) window.Android.save(val);
          else console.log("Mock Save:", val);
        };

        window.__getCode = function () {
          return getCode();
        };

        // window.addEventListener("resize", () => {
        //   if (fontSize === "auto") applyFontSize("auto");
        // });
        const __err = console.error.bind(console);
        console.error = function (...args) {
          const safe = args
            .map((a) => {
              if (typeof a === "string") return a;
              try {
                return JSON.stringify(a);
              } catch (e) {
                return String(a);
              }
            })
            .join(" ");
          appendLog("error", safe);
          __err(...args);
        };
      } catch (e) {
        const msg = e && e.message ? e.message : e;
        if (window.__LEGADO_BOOT_ERROR) {
          window.__LEGADO_BOOT_ERROR("ÁºñËæëÂô®ÂàùÂßãÂåñÂ§±Ë¥•: " + msg);
        }
      }
    })();
  </script>
</body>

</html>
