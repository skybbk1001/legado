<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Legado Editor Pro</title>
  <style>
    :root {
      --bg: #ffffff;
      --gutter-bg: #f5f5f5;
      --gutter-text: #b0b0b0;
      --text: #24292e;
      --border: #e1e4e8;
      --active-line: #f6f8fa;
      --accent: #0366d6;
      --toolbar-bg: #f8f9fa;
      --selection: #b3d7ff;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #1e1e1e;
        --gutter-bg: #252526;
        --gutter-text: #858585;
        --text: #d4d4d4;
        --border: #3e3e42;
        --active-line: #2d2d30;
        --accent: #40a9ff;
        --toolbar-bg: #252526;
        --selection: #264f78;
      }
    }

    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    body {
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px;
      background: var(--toolbar-bg);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
      flex-shrink: 0;
    }
    #toolbar::-webkit-scrollbar { display: none; }

    .btn {
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
    }
    .btn:active { opacity: 0.7; }
    .btn.active {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--active-line);
    }
    .btn.btn-icon {
      padding: 6px 8px;
      min-width: 28px;
    }

    #editor-container {
      position: relative;
      flex: 1;
      display: flex;
      min-height: 0;
    }

    #lines {
      width: 45px;
      padding: 10px 5px 10px 0;
      background: var(--gutter-bg);
      color: var(--gutter-text);
      text-align: right;
      font-size: 13px;
      line-height: 1.5;
      border-right: 1px solid var(--border);
      overflow: hidden;
      user-select: none;
      white-space: pre;
    }

    #code {
      flex: 1;
      border: 0;
      padding: 10px;
      margin: 0;
      font-size: 13px;
      line-height: 1.5;
      outline: none;
      resize: none;
      background: transparent;
      color: var(--text);
      overflow: auto;
      white-space: pre;
      tab-size: 2;
    }
    #code::selection { background: var(--selection); }

    #measure {
      position: absolute;
      top: -9999px;
      left: -9999px;
      visibility: hidden;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    /* ÊêúÁ¥¢Ê°Ü */
    #search-box {
      position: absolute;
      top: 0; right: 0;
      background: var(--toolbar-bg);
      padding: 6px;
      border-bottom: 1px solid var(--border);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 10;
      transform: translateY(-100%);
      transition: transform 0.2s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    #search-box.visible { transform: translateY(0); }
    .search-row { display: flex; gap: 4px; align-items: center; }
    .search-input {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 4px 6px;
      font-size: 13px;
      width: 140px;
      border-radius: 3px;
    }
    .search-input:focus { border-color: var(--accent); }

    #format-options {
      position: absolute;
      top: 44px;
      right: 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 8px 10px;
      display: none;
      z-index: 30;
      font-size: 13px;
    }
    #format-options.show { display: block; }
    #format-options .opt {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    #format-options input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
    }
    #format-options select {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
    }

    #toast {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 20;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>

  <div id="toolbar">
    <button id="undoBtn" class="btn">Êí§ÈîÄ</button>
    <button id="redoBtn" class="btn">ÈáçÂÅö</button>
    <button id="wrapBtn" class="btn">Êç¢Ë°å</button>
    <button id="formatBtn" class="btn">Ê†ºÂºèÂåñ</button>
    <button id="formatOptionsBtn" class="btn btn-icon" title="Ê†ºÂºèÂåñÈÄâÈ°π">‚ñæ</button>
    <button id="searchToggleBtn" class="btn">üîç</button>
  </div>

  <div id="format-options">
    <label class="opt">
      <input id="wrapElementsToggle" type="checkbox" checked />
      <span>ÂÖÉÁ¥†Êç¢Ë°å</span>
    </label>
    <label class="opt">
      <span>Áº©Ëøõ</span>
      <select id="indentSizeSelect">
        <option value="2" selected>2</option>
        <option value="4">4</option>
      </select>
    </label>
    <label class="opt">
      <span>ÂÆΩÂ∫¶</span>
      <select id="printWidthSelect">
        <option value="80">80</option>
        <option value="120" selected>120</option>
        <option value="160">160</option>
      </select>
    </label>
    <label class="opt">
      <input id="singleQuoteToggle" type="checkbox" />
      <span>ÂçïÂºïÂè∑</span>
    </label>
    <label class="opt">
      <input id="trailingCommaToggle" type="checkbox" checked />
      <span>Êú´Â∞æÈÄóÂè∑</span>
    </label>
  </div>

  <div id="search-box">
    <div class="search-row">
      <input id="search-input" class="search-input" type="text" placeholder="Êü•Êâæ..." />
      <button id="findPrevBtn" class="btn">‚Üë</button>
      <button id="findNextBtn" class="btn">‚Üì</button>
      <button id="closeSearchBtn" class="btn" style="border:none;">√ó</button>
    </div>
    <div class="search-row">
      <input id="replace-input" class="search-input" type="text" placeholder="ÊõøÊç¢‰∏∫..." />
      <button id="replaceBtn" class="btn">ÊõøÊç¢</button>
      <button id="replaceAllBtn" class="btn">ÂÖ®ÈÉ®</button>
    </div>
  </div>

  <div id="editor-container">
    <div id="lines">1</div>
    <textarea id="code" spellcheck="false" autocapitalize="off" autocomplete="off"></textarea>
    <div id="measure"></div>
  </div>

  <div id="toast"></div>

  <script src="standalone.min.js"></script>
  <script src="babel.js"></script>
  <script src="estree.js"></script>
  <script>
    (function () {
      function debounce(fn, wait) {
        let t;
        return function (...args) {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      const code = document.getElementById("code");
      const lines = document.getElementById("lines");
      const measure = document.getElementById("measure");
      const toast = document.getElementById("toast");
      
      let isWrap = false;
      let wrapElements = true;
      let historyStack = [];
      let historyIndex = -1;
      let lastValue = "";
      let lastFormatter = "";
      let lastPrettierError = "";
      let tabSize = 2;
      let printWidth = 120;
      let singleQuote = false;
      let trailingComma = true;
      let TAB = "  ";

      // --- Ë°åÂè∑ÈÄªËæëÔºàÊç¢Ë°åÊó∂ÊòæÁ§∫Á©∫Ë°åÂç†‰ΩçÔºå‰∏çÂ¢ûÂä†Ë°åÂè∑Ôºâ ---
      function buildLineNumbers(text) {
        const rawLines = (text || "").split("\n");
        if (!isWrap || !measure) {
          return rawLines.map((_, i) => String(i + 1));
        }

        const style = window.getComputedStyle(code);
        const lineHeight = parseFloat(style.lineHeight) || 20;
        const padLeft = parseFloat(style.paddingLeft) || 0;
        const padRight = parseFloat(style.paddingRight) || 0;
        const width = Math.max(0, code.clientWidth - padLeft - padRight);

        measure.style.fontFamily = style.fontFamily;
        measure.style.fontSize = style.fontSize;
        measure.style.lineHeight = style.lineHeight;
        measure.style.width = width + "px";

        const out = [];
        for (let i = 0; i < rawLines.length; i++) {
          const lineText = rawLines[i];
          measure.textContent = lineText || " ";
          const visualCount = Math.max(1, Math.round(measure.scrollHeight / lineHeight));
          out.push(String(i + 1));
          for (let k = 1; k < visualCount; k++) {
            out.push("");
          }
        }
        return out;
      }

      const updateLines = () => {
        const val = code.value;
        const lineTexts = buildLineNumbers(val);
        const lineCount = lineTexts.length;
        if (lines.getAttribute("data-lines") != lineCount) {
          lines.setAttribute("data-lines", lineCount);
        }
        lines.textContent = lineTexts.join("\n");
        const lastNumber = String((val.match(/\n/g) || []).length + 1);
        lines.style.width = Math.max(3, lastNumber.length + 1) + "ch";
      };
      const debouncedUpdateLines = debounce(updateLines, 30);

      // ÊªöÂä®ÂêåÊ≠•
      let ticking = false;
      code.addEventListener("scroll", () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            lines.scrollTop = code.scrollTop;
            ticking = false;
          });
          ticking = true;
        }
      });

      code.addEventListener("input", () => {
        saveHistory();
        if (isWrap) {
          debouncedUpdateLines();
        } else {
          updateLines();
        }
      });

      // --- ÂéÜÂè≤ËÆ∞ÂΩï ---
      function saveHistory() {
        const val = code.value;
        if (val === lastValue) return;
        if (historyIndex < historyStack.length - 1) {
          historyStack = historyStack.slice(0, historyIndex + 1);
        }
        historyStack.push(val);
        historyIndex++;
        if (historyStack.length > 50) {
          historyStack.shift();
          historyIndex--;
        }
        lastValue = val;
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          code.value = historyStack[historyIndex];
          lastValue = code.value;
          updateLines();
          showToast("Êí§ÈîÄ");
        }
      }

      function redo() {
        if (historyIndex < historyStack.length - 1) {
          historyIndex++;
          code.value = historyStack[historyIndex];
          lastValue = code.value;
          updateLines();
          showToast("ÈáçÂÅö");
        }
      }

      saveHistory(); // ÂàùÂßãÂåñ

      // --- Ê†ºÂºèÂåñÊ†∏ÂøÉÁÆóÊ≥ï (‰øÆÂ§çÁâà) ---
      
      // 1. ‰∏•Ê†º JSON Ê†ºÂºèÂåñ (ÊúÄ‰ºòÂÖà)
      function tryFormatJSON(text, compact) {
        try {
          return JSON.stringify(JSON.parse(text), null, compact ? 0 : TAB);
        } catch (e) {
          return null;
        }
      }

      // 2. ÂÆΩÊùæ JS/JSON Ê†ºÂºèÂåñÔºà‰∏§Èò∂ÊÆµÔºöËßÑËåÉÊç¢Ë°å + Áº©ËøõÔºâ
      function normalizeJs(text) {
        let out = "";
        let inString = false;
        let stringChar = "";
        let escape = false;
        let inLineComment = false;
        let inBlockComment = false;
        let parenDepth = 0;
        let braceDepth = 0;
        let ternaryDepth = 0;
        let inRegex = false;
        let inCharClass = false;
        let regexEscape = false;
        let lastNonSpace = "";

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          const next = text[i + 1];

          if (inLineComment) {
            out += ch;
            if (ch === "\n") inLineComment = false;
            continue;
          }
          if (inBlockComment) {
            out += ch;
            if (ch === "*" && next === "/") {
              out += next;
              i++;
              inBlockComment = false;
            }
            continue;
          }

          if (inRegex) {
            out += ch;
            if (regexEscape) {
              regexEscape = false;
              continue;
            }
            if (ch === "\\") {
              regexEscape = true;
              continue;
            }
            if (ch === "[" && !inCharClass) {
              inCharClass = true;
              continue;
            }
            if (ch === "]" && inCharClass) {
              inCharClass = false;
              continue;
            }
            if (ch === "/" && !inCharClass) {
              inRegex = false;
            }
            continue;
          }

          if (inString) {
            out += ch;
            if (escape) {
              escape = false;
            } else if (ch === "\\") {
              escape = true;
            } else if (ch === stringChar) {
              inString = false;
              stringChar = "";
            }
            continue;
          }

          if (ch === "/" && next === "/") {
            out += ch + next;
            i++;
            inLineComment = true;
            continue;
          }
          if (ch === "/" && next === "*") {
            out += ch + next;
            i++;
            inBlockComment = true;
            continue;
          }
          if (ch === "/" && next !== "/" && next !== "*") {
            const regexStart = !lastNonSpace || /[=({\[;,?:!&|+\-*%^~<>]/.test(lastNonSpace);
            if (regexStart) {
              inRegex = true;
              out += ch;
              continue;
            }
          }

          if (ch === '"' || ch === "'" || ch === "`") {
            inString = true;
            stringChar = ch;
            out += ch;
            continue;
          }

          if (ch === "(") {
            parenDepth++;
            out += ch;
            continue;
          }
          if (ch === ")") {
            parenDepth = Math.max(parenDepth - 1, 0);
            out += ch;
            continue;
          }

          if (ch === "{") {
            braceDepth++;
            out += wrapElements ? "{\n" : "{ ";
            if (!/\s/.test(ch)) lastNonSpace = ch;
            continue;
          }
          if (ch === "}") {
            braceDepth = Math.max(braceDepth - 1, 0);
            out += wrapElements ? "\n}\n" : " }\n";
            if (!/\s/.test(ch)) lastNonSpace = ch;
            continue;
          }
          if (ch === "?" && next === "?") {
            const next2 = text[i + 2] || "";
            if (next2 === "=") {
              out += "??=";
              i += 2;
            } else {
              out += "??";
              i += 1;
            }
            lastNonSpace = "?";
            continue;
          }
          if (ch === "?" && next === ".") {
            out += "?.";
            i += 1;
            lastNonSpace = ".";
            continue;
          }
          if (ch === "?" && next !== "?" && parenDepth === 0) {
            ternaryDepth += 1;
            out += "\n? ";
            if (!/\s/.test(ch)) lastNonSpace = ch;
            continue;
          }
          if (ch === ":" && ternaryDepth > 0 && parenDepth === 0 && braceDepth === 0) {
            ternaryDepth -= 1;
            out += "\n: ";
            if (!/\s/.test(ch)) lastNonSpace = ch;
            continue;
          }
          if (ch === ";" && parenDepth === 0) {
            out += ";\n";
            if (!/\s/.test(ch)) lastNonSpace = ch;
            continue;
          }
          if (ch === "," && parenDepth === 0) {
            out += wrapElements ? ",\n" : ", ";
            if (!/\s/.test(ch)) lastNonSpace = ch;
            continue;
          }
          if (ch === "\r") continue;

          out += ch;
          if (!/\s/.test(ch)) lastNonSpace = ch;
        }
        return out.replace(/\n{2,}/g, "\n");
      }

      function countBraceDelta(line) {
        let open = 0;
        let close = 0;
        let inString = false;
        let stringChar = "";
        let escape = false;

        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          const next = line[i + 1];

          if (!inString && ch === "/" && next === "/") {
            break;
          }
          if (!inString && ch === "/" && next === "*") {
            const end = line.indexOf("*/", i + 2);
            if (end === -1) break;
            i = end + 1;
            continue;
          }

          if (inString) {
            if (escape) {
              escape = false;
            } else if (ch === "\\") {
              escape = true;
            } else if (ch === stringChar) {
              inString = false;
              stringChar = "";
            }
            continue;
          }

          if (ch === '"' || ch === "'" || ch === "`") {
            inString = true;
            stringChar = ch;
            continue;
          }

          if (ch === "{" || ch === "[") open++;
          if (ch === "}" || ch === "]") close++;
        }
        return open - close;
      }

      function indentJsLines(text) {
        const lines = text.split("\n");
        const out = [];
        let indent = 0;
        let prevTrimmed = "";

        lines.forEach(function (line) {
          let trimmed = line.trim();
          if (!trimmed) return;

          trimmed = normalizeKeywordLine(trimmed);
          const startsWithClose = /^[}\]]/.test(trimmed);
          if (startsWithClose) indent = Math.max(indent - 1, 0);

          const prevIsCase = /^(case\b|default\b)/.test(prevTrimmed);
          const prevContinuation =
            !prevIsCase &&
            (/[=,+\-*/%&|^?:]$/.test(prevTrimmed) || /[({[]$/.test(prevTrimmed));

          let lineIndent = indent + (prevContinuation ? 1 : 0);
          if (/^[?:]/.test(trimmed)) {
            lineIndent = indent + 1;
          }
          const canMerge =
            /^(else\b|catch\b|finally\b)/.test(trimmed) &&
            out.length > 0 &&
            out[out.length - 1].trim().endsWith("}");
          if (canMerge) {
            out[out.length - 1] = out[out.length - 1] + " " + trimmed;
          } else {
            out.push(TAB.repeat(lineIndent) + trimmed);
          }

          let delta = countBraceDelta(trimmed);
          if (startsWithClose) delta += 1;
          indent += delta;
          if (indent < 0) indent = 0;

          if (/^(case\b|default\b)/.test(trimmed) && /:\s*$/.test(trimmed)) {
            indent += 1;
          }
          prevTrimmed = trimmed;
        });

        return out.join("\n");
      }

      function formatLooseJS(text) {
        const normalized = normalizeJs(text);
        return indentJsLines(normalized);
      }

      async function formatWithPrettier(codeText, parser) {
        if (!window.prettier || !window.prettierPlugins) {
          lastPrettierError = "Prettier Êú™Âä†ËΩΩ";
          return null;
        }
        const plugins = [];
        if (window.prettierPlugins.babel) plugins.push(window.prettierPlugins.babel);
        if (window.prettierPlugins.estree) plugins.push(window.prettierPlugins.estree);
        if (!plugins.length) {
          lastPrettierError = "Prettier Êèí‰ª∂Êú™Âä†ËΩΩ";
          return null;
        }
        try {
          const width = wrapElements ? printWidth : Math.max(printWidth, 99999);
          return await window.prettier.format(codeText, {
            parser: parser || "babel",
            plugins: plugins,
            tabWidth: tabSize,
            useTabs: false,
            singleQuote: singleQuote,
            trailingComma: trailingComma ? "es5" : "none",
            printWidth: width
          });
        } catch (e) {
          lastPrettierError = e && e.message ? e.message : "Prettier Ëß£ÊûêÂ§±Ë¥•";
          console.error("Prettier error:", e);
          return null;
        }
      }

      async function formatJsBlock(codeText) {
        const pretty = await formatWithPrettier(codeText, "babel");
        if (pretty) {
          lastFormatter = "prettier";
          return pretty;
        }
        lastFormatter = "loose";
        return formatLooseJS(codeText);
      }

      function looksLikeHtml(text) {
        const trimmed = (text || "").trim();
        if (!trimmed) return false;
        if (!/^</.test(trimmed)) return false;
        return /^<(?:!doctype|html|head|body|div|span|p|section|article|script|style)\b/i.test(trimmed) ||
          (/^<[^>]+>/.test(trimmed) && /<\/[^>]+>/.test(trimmed));
      }

      async function formatCode() {
        const raw = code.value || "";
        const text = raw.trim();
        if (!text) return;
        lastFormatter = "";
        lastPrettierError = "";
        showToast("Ê†ºÂºèÂåñ‰∏≠...");
        await new Promise(requestAnimationFrame);

        try {
          const wrapper = detectWrapper(raw);
          if (wrapper) {
            const bodyText = (wrapper.body || "").trim();
            const formattedBody = bodyText ? await formatJsBlock(bodyText) : "";
            let wrapped = "";
            if (wrapper.type === "prefix") {
              wrapped = wrapper.prefix + (formattedBody ? "\n" + formattedBody : "");
            } else if (wrapper.type === "tag") {
              wrapped = wrapper.open + (formattedBody ? "\n" + formattedBody + "\n" : "") + wrapper.close;
            } else if (wrapper.type === "moustache") {
              wrapped = "{{" + (formattedBody ? "\n" + formattedBody + "\n" : "") + "}}";
            } else {
              wrapped = formattedBody;
            }
            code.value = wrapped;
            updateLines();
            saveHistory();
            const modeLabel = lastFormatter === "prettier" ? "Prettier" : "ÂÆΩÊùæ";
            showToast("Ê†ºÂºèÂåñÂÆåÊàêÔºà" + modeLabel + "Ôºâ");
            return;
          }

          // 1. Â∞ùËØïÊ†áÂáÜ JSON
          let formatted = tryFormatJSON(text, !wrapElements);
          if (!formatted) {
            const prettyJson = await formatWithPrettier(text, "json");
            if (prettyJson) {
              formatted = prettyJson.trimEnd();
              lastFormatter = "prettier";
            }
          }

          if (!formatted) {
            if (looksLikeHtml(text)) {
              // 2. ÁÆÄÂçïÁöÑ HTML Áº©Ëøõ
              formatted = formatHtml(text);
            } else {
              // 3. JS / ÂÖ∂‰ªñËÑöÊú¨
              formatted = await formatJsBlock(text);
            }
          }

          if (formatted) {
              code.value = formatted;
              updateLines();
              saveHistory();
            const modeLabel = lastFormatter === "prettier" ? "Prettier" : "ÂÆΩÊùæ";
            if (lastFormatter === "loose" && lastPrettierError) {
              const err = String(lastPrettierError || "").trim();
              const shortErr = err.length > 80 ? err.slice(0, 80) + "‚Ä¶" : err;
              showToast("Ê†ºÂºèÂåñÂÆåÊàêÔºàÂÆΩÊùæÔºåPrettierÂ§±Ë¥•Ôºö" + shortErr + "Ôºâ");
            } else {
              showToast("Ê†ºÂºèÂåñÂÆåÊàêÔºà" + modeLabel + "Ôºâ");
            }
          } else {
              showToast("Ê†ºÂºèÂåñÂ§±Ë¥•");
          }
        } catch (e) {
          console.error(e);
          showToast("Ê†ºÂºèÂåñÂ§±Ë¥•");
        }
      }

      function formatHtml(html) {
        let tab = TAB;
        let result = '';
        let indent= '';
        html.split(/>\s*</).forEach(function(element) {
          if (element.match( /^\/\w/ )) {
            indent = indent.substring(tab.length);
          }
          result += indent + '<' + element + '>\r\n';
          // ÊéíÈô§ void tags (‰∏çÈúÄË¶ÅÈó≠ÂêàÁöÑÊ†áÁ≠æ)
          if (element.match( /^<?\w[^>]*[^\/]$/ ) && !/^br|^img|^hr|^input|^meta|^link/i.test(element) ) { 
            indent += tab;              
          }
        });
        return result.substring(1, result.length-3);
      }

      function normalizeKeywordLine(line) {
        return line
          .replace(/^else\s*if\s*\(/, "else if (")
          .replace(/^else\s*\{/, "else {")
          .replace(/^catch\s*\(/, "catch (")
          .replace(/^finally\s*\{/, "finally {");
      }

      function detectWrapper(rawText) {
        const raw = rawText || "";
        const trimmed = raw.trim();
        const jsPrefixMatch = raw.match(/^\s*@js:\s*[\r\n]?([\s\S]*)$/);
        if (jsPrefixMatch) {
          return { type: "prefix", prefix: "@js:", body: jsPrefixMatch[1] || "" };
        }
        const tagMatch = trimmed.match(/^<js>\s*([\s\S]*?)\s*<\/js>$/i);
        if (tagMatch) {
          return { type: "tag", open: "<js>", close: "</js>", body: tagMatch[1] };
        }
        const braceMatch = trimmed.match(/^\{\{\s*([\s\S]*?)\s*\}\}$/);
        if (braceMatch) {
          return { type: "moustache", body: braceMatch[1] };
        }
        return null;
      }

      // --- ‰∫ã‰ª∂ÁªëÂÆö ---
      document.getElementById("undoBtn").onclick = undo;
      document.getElementById("redoBtn").onclick = redo;
      document.getElementById("formatBtn").onclick = formatCode;
      
      const wrapBtn = document.getElementById("wrapBtn");
      wrapBtn.onclick = () => {
        isWrap = !isWrap;
        code.style.whiteSpace = isWrap ? "pre-wrap" : "pre";
        wrapBtn.classList.toggle("active", isWrap);
        updateLines();
        showToast("Ëá™Âä®Êç¢Ë°å: " + (isWrap ? "ÂºÄ" : "ÂÖ≥"));
      };

      const formatOptionsBtn = document.getElementById("formatOptionsBtn");
      const formatOptions = document.getElementById("format-options");
      const wrapElementsToggle = document.getElementById("wrapElementsToggle");
      const indentSizeSelect = document.getElementById("indentSizeSelect");
      const printWidthSelect = document.getElementById("printWidthSelect");
      const singleQuoteToggle = document.getElementById("singleQuoteToggle");
      const trailingCommaToggle = document.getElementById("trailingCommaToggle");

      function applyTabSize(size) {
        tabSize = size;
        TAB = " ".repeat(tabSize);
        code.style.tabSize = String(tabSize);
      }

      wrapElementsToggle.checked = wrapElements;
      indentSizeSelect.value = String(tabSize);
      printWidthSelect.value = String(printWidth);
      singleQuoteToggle.checked = singleQuote;
      trailingCommaToggle.checked = trailingComma;
      applyTabSize(tabSize);

      wrapElementsToggle.addEventListener("change", () => {
        wrapElements = wrapElementsToggle.checked;
        showToast("ÂÖÉÁ¥†Êç¢Ë°å: " + (wrapElements ? "ÂºÄ" : "ÂÖ≥"));
      });
      indentSizeSelect.addEventListener("change", () => {
        applyTabSize(parseInt(indentSizeSelect.value, 10) || 2);
        showToast("Áº©Ëøõ: " + tabSize);
      });
      printWidthSelect.addEventListener("change", () => {
        printWidth = parseInt(printWidthSelect.value, 10) || 120;
        showToast("ÂÆΩÂ∫¶: " + printWidth);
      });
      singleQuoteToggle.addEventListener("change", () => {
        singleQuote = singleQuoteToggle.checked;
        showToast("ÂçïÂºïÂè∑: " + (singleQuote ? "ÂºÄ" : "ÂÖ≥"));
      });
      trailingCommaToggle.addEventListener("change", () => {
        trailingComma = trailingCommaToggle.checked;
        showToast("Êú´Â∞æÈÄóÂè∑: " + (trailingComma ? "ÂºÄ" : "ÂÖ≥"));
      });

      formatOptionsBtn.onclick = (e) => {
        e.stopPropagation();
        formatOptions.classList.toggle("show");
      };
      document.addEventListener("click", (e) => {
        if (!formatOptions.classList.contains("show")) return;
        if (formatOptions.contains(e.target) || e.target === formatOptionsBtn) return;
        formatOptions.classList.remove("show");
      });

      // ÊêúÁ¥¢ÂäüËÉΩ
      const searchBox = document.getElementById("search-box");
      const searchInput = document.getElementById("search-input");
      const replaceInput = document.getElementById("replace-input");
      const findPrevBtn = document.getElementById("findPrevBtn");
      const findNextBtn = document.getElementById("findNextBtn");
      const replaceBtn = document.getElementById("replaceBtn");
      const replaceAllBtn = document.getElementById("replaceAllBtn");
      const closeSearchBtn = document.getElementById("closeSearchBtn");

      document.getElementById("searchToggleBtn").onclick = () => {
        searchBox.classList.add("visible");
        searchInput.focus();
      };
      closeSearchBtn.onclick = () => searchBox.classList.remove("visible");

      function doSearch(dir) {
        const query = searchInput.value;
        if (!query) return;
        const text = code.value;
        let index = -1;
        if (dir === 1) {
          const startPos = code.selectionEnd;
          index = text.indexOf(query, startPos);
          if (index === -1) index = text.indexOf(query, 0);
        } else {
          const startPos = Math.max(0, code.selectionStart - 1);
          index = text.lastIndexOf(query, startPos);
          if (index === -1) index = text.lastIndexOf(query);
        }
        if (index !== -1) {
          code.setSelectionRange(index, index + query.length);
          code.focus();
          const lineHeight = 20;
          const linesBefore = text.substring(0, index).split("\n").length;
          code.scrollTop = (linesBefore * lineHeight) - (code.clientHeight / 2);
        } else {
          showToast("Êú™ÊâæÂà∞ÂÜÖÂÆπ");
        }
      }

      function doReplace(all) {
        const query = searchInput.value;
        if (!query) return;
        const replacement = replaceInput.value || "";
        if (all) {
          if (code.value.includes(query)) {
            code.value = code.value.split(query).join(replacement);
            updateLines();
            saveHistory();
            showToast("ÂÖ®ÈÉ®ÊõøÊç¢ÂÆåÊàê");
          }
          return;
        }
        const start = code.selectionStart;
        const end = code.selectionEnd;
        const selected = code.value.substring(start, end);
        if (selected === query) {
          insertText(replacement);
          doSearch(1);
        } else {
          doSearch(1);
        }
      }

      findNextBtn.onclick = () => doSearch(1);
      findPrevBtn.onclick = () => doSearch(-1);
      replaceBtn.onclick = () => doReplace(false);
      replaceAllBtn.onclick = () => doReplace(true);

      function insertText(text) {
        const start = code.selectionStart;
        const end = code.selectionEnd;
        code.setRangeText(text, start, end, "end");
        code.dispatchEvent(new Event('input'));
      }

      // Âø´Êç∑ÈîÆÂ¢ûÂº∫
      code.addEventListener("keydown", function (e) {
        if (e.isComposing) return;
        const pairMap = {
          "(": ")",
          "[": "]",
          "{": "}",
          "'": "'",
          "\"": "\"",
          "`": "`"
        };
        const closeMap = {
          ")": "(",
          "]": "[",
          "}": "{",
          "'": "'",
          "\"": "\"",
          "`": "`"
        };

        if (!e.ctrlKey && !e.metaKey && !e.altKey && pairMap[e.key]) {
          e.preventDefault();
          const start = code.selectionStart;
          const end = code.selectionEnd;
          const selected = code.value.substring(start, end);
          const close = pairMap[e.key];
          const insert = e.key + selected + close;
          code.setRangeText(insert, start, end, "end");
          if (selected) {
            code.setSelectionRange(start + 1, start + 1 + selected.length);
          } else {
            const pos = start + 1;
            code.setSelectionRange(pos, pos);
          }
          code.dispatchEvent(new Event("input"));
          return;
        }

        if (!e.ctrlKey && !e.metaKey && !e.altKey && closeMap[e.key]) {
          const start = code.selectionStart;
          const end = code.selectionEnd;
          if (start === end) {
            const next = code.value[start];
            if (next === e.key) {
              e.preventDefault();
              code.setSelectionRange(start + 1, start + 1);
              return;
            }
          }
        }

        if (e.key === "Backspace") {
          const start = code.selectionStart;
          const end = code.selectionEnd;
          if (start === end && start > 0) {
            const prev = code.value[start - 1];
            const next = code.value[start];
            if (pairMap[prev] && pairMap[prev] === next) {
              e.preventDefault();
              code.setRangeText("", start - 1, start + 1, "start");
              code.dispatchEvent(new Event("input"));
              return;
            }
          }
        }
        if (e.key === "Tab") {
          e.preventDefault();
          insertText(TAB);
        }
        if (e.key === "Enter") {
          e.preventDefault();
          const cursor = code.selectionStart;
          const currentLineStart = code.value.lastIndexOf("\n", cursor - 1) + 1;
          const currentLine = code.value.substring(currentLineStart, cursor);
          const indent = (currentLine.match(/^\s*/) || [""])[0];
          const extraIndent = /[{[]\s*$/.test(currentLine) ? TAB : "";
          const nextChar = code.value[cursor] || "";
          if (extraIndent && (nextChar === "}" || nextChar === "]")) {
            const insert = "\n" + indent + extraIndent + "\n" + indent;
            code.setRangeText(insert, cursor, cursor, "end");
            const pos = cursor + 1 + indent.length + extraIndent.length;
            code.setSelectionRange(pos, pos);
            code.dispatchEvent(new Event("input"));
            return;
          }
          insertText("\n" + indent + extraIndent);
        }
      });

      function showToast(msg) {
        toast.textContent = msg;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 1500);
      }

      // --- Android Interface ---
      function b64ToUtf8(b64) {
        try { return decodeURIComponent(escape(window.atob(b64))); } catch (e) { return ""; }
      }

      window.setCodeFromAndroid = function (b64) {
        code.value = b64ToUtf8(b64);
        updateLines();
        saveHistory();
        code.scrollTop = 0;
        lines.scrollTop = 0;
      };

      window.__save = function () {
        const val = code.value || "";
        if (window.Android && window.Android.save) window.Android.save(val);
        else console.log("Mock Save:", val);
      };

      window.__getCode = function () {
        return code.value || "";
      };
      
      window.addEventListener("resize", debouncedUpdateLines);
      updateLines();
    })();
  </script>
</body>
</html>
